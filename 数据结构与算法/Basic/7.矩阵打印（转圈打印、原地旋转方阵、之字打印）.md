## 矩阵打印
### 1.转圈打印二维矩阵
#### 1）问题
剑指offer第29题：[http://t.cn/Rrq6tsv](http://t.cn/Rrq6tsv "面试题29")

	【题目】 
		给定一个整型矩阵matrix， 请按照转圈的方式打印它。
		例如： 
			 1  2  3  4 
			 5  6  7  8 
			 9 10 11 12 
			13 14 15 16 
		打印结果为： 1， 2， 3， 4， 8， 12， 16， 15， 14， 13， 9，5， 6， 7， 11， 10
	【要求】 
		额外空间复杂度为O(1)。
#### 2）分析
从宏观的角度考虑这个问题

每次都是顺时针打印外框

打印框时只需要两个点：左上角的点（a,b）右下角的点（c,d）

向右打印（a,b->d-1）

向下打印（a->c-1,d）

向左打印（c,d->b+1）

向上打印（c->a+1,b）

打印完了，（a+1,b+1）,(c-1,d-1)

直到a>c或b>d

#### 3)代码

	public ArrayList<Integer> printMatrix(int[][] matrix) {
		ArrayList<Integer> res = new ArrayList<Integer>();
		if (matrix == null || matrix.length == 0) {
			return res;
		}
		int a = 0;
		int b = 0;
		int c = matrix.length - 1;
		int d = matrix[0].length - 1;
		while (a <= c && b <= d) {
			printEdge(matrix, a++, b++, c--, d--, res);
		}
		return res;
	}

	public void printEdge(int[][] matrix, int a, int b, int c, int d, ArrayList<Integer> res) {
		int cur = 0;
		// 只有一行
		if (a == c) {
			cur = b;
			while (cur <= d) {
				res.add(matrix[a][cur++]);
			}
			return;
		}
		// 只有一列
		if (b == d) {
			cur = a;
			while (cur <= c) {
				res.add(matrix[cur++][b]);
			}
			return;
		}
		// 向右（a,b->d-1）
		cur = b;
		while (cur < d) {
			res.add(matrix[a][cur++]);
		}
		// 向下（a->c-1,d）
		cur = a;
		while (cur < c) {
			res.add(matrix[cur++][d]);
		}
		// 向左（c,d->b+1）
		cur = d;
		while (cur > b) {
			res.add(matrix[c][cur--]);
		}
		// 向上（c->a+1,b）
		cur = c;
		while (cur > a) {
			res.add(matrix[cur--][b]);
		}
	}

### 2.旋转正方形矩阵
#### 1）问题

【题目】 给定一个整型正方形矩阵matrix， 请把该矩阵调整成顺时针旋转90度的样子。

【要求】 额外空间复杂度为O(1)。

#### 2）分析
宏观的角度思考该问题

对每一条框进行旋转

旋转框时

#### 3）代码

	public static void rotateMatrix(int[][] matrix) {
		if (matrix == null || matrix.length <= 1) {
			return;
		}
		// n*n的方阵
		int n = matrix.length;
		// 奇数中间的一个点不用动
		// (i,i)表示边框的起点
		for (int i = 0; i < n / 2; i++) {
			rotateEdge(matrix, i);
		}
	}

	private static void rotateEdge(int[][] matrix, int i) {
		int n = matrix.length;
		// （i,i）——>(i,n-2-i)需要移动的边框的移动轨迹
		for (int j = 0; j < n - 1 - 2 * i; j++) {
			int tmp = matrix[i][i + j];
			matrix[i][i + j] = matrix[n - 1 - i - j][i];
			matrix[n - 1 - i - j][i] = matrix[n - 1 - i][n - 1 - i - j];
			matrix[n - 1 - i][n - 1 - i - j] = matrix[i + j][n - 1 - i];
			matrix[i + j][n - 1 - i] = tmp;
		}
	}
