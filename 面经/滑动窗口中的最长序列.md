**题目描述**

有一套系统需升级，为减小系统升级期间的影响，需根据系统过去几周内的平均每小时的访问数据，来预则最佳升
级时间窗。时间窗选择规则如下:

- 升级时间窗内累计用户访问量必须小于等于给定的**容忍值**。


- 升级时间意必须是连续的x个小时，越大越好，最大的x即为最住升级时间窗，且**不起过7*24**。


- 升级时间允许跨周期。

现给定升级影响的容忍值，和一个周期 (7*24) 的每小时用户访问量的历史数据 (整数数组)。
请计算最佳升级时间窗，并返回其开始时间和结束时间的下标。 如果存在多个最住升级时间窗时，返回开始时间下
标最小的一个。

**输入**

第一行为整数 n ，表示给定的升级影响的容忍值，取值范围: [0，2^31)。

第二行为7*24个区数，表示一个周期 (7*24) 的每个小时用户访问量，每个值的范围: [0，2^31)。

**输出**

两个整数，分别表示所计算出的最住升级时间窗的开始时间下标(包含)和结束时间下标(包含)，不存在时返回-1

**样例**

输入样例1

    6
    1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1

输出样例1

    22 25

输入样例2

    7
    4 1 31 42 30 23 17 50 21 10 110 60 121 110 15 30 3 1 23 32 42 31 21 13 15 21 31 42 32 23 17 8 9 10 110 121 121 110 10 9 8 17 23 32 42 31 21 10 10 21 31 42 32 23 17 8 9 10 110 121 121 110 10 9 8 17 23 32 42 31 21 10 10 21 31 42 32 23 17 8 9 10 110 121 121 110 10 9 8 17 23 32 42 31 21 10 10 21 31 42 32 23 17 8 9 10 110 121 121 110 10 9 8 17 23 32 42 31 21 10 10 21 31 42 32 23 17 8 9 10 110 121 121 110 10 9 8 17 23 32 42 31 21 10 10 21 31 42 32 23 17 8 9 10 110 121 121 110 10 9 8 17 23 32 42 31 21 1

输出样例2


    167 1

**提示**

样例1解释: 存在多个最住升级时间窗，开始时间下标最小为22，结束时间下标为25

样例2解释: 下标[2,166]之间的数据部大于容忍值7，下标167、0、1的值之和为 1 + 4 + 1 = 6，小于等于容忍
值，存在跨周期，所以输出[167,1]。


    #include <iostream>
	#include <string>
	#include <sstream>
	#include <vector>
	using namespace std;
	
	#define ARR_LEN (7 * 24)
	
	// 待实现函数，在此函数中填入答题代码
	class Solution
	{
	public:
	    vector<int> GetBestTimeWindow(int n, const vector<int> &arr) const
	    {
	        // TODO: 在此添加你的代码
	        return vector<int>();
	    }
	};
	
	
	// 以下为考题输入输出框架，此部分代码不建议改动
	inline int ReadInt()
	{
	    int number;
	    std::cin >> number;
	    return number;
	}
	
	template<typename T>
	inline std::vector<T> ReadVector(int size)
	{
	    std::vector<T> objects(size);
	    for (int i = 0; i < size; ++i) {
	        std::cin >> objects[i];
	    }
	    return objects;
	}
	
	template<typename T>
	inline void WriteVector(const std::vector<T>& objects, char delimeter = ' ')
	{
	    auto it = objects.begin();
	    if (it == objects.end()) {
	        return;
	    }
	    std::cout << *it;
	    for (++it; it != objects.end(); ++it) {
	        std::cout << delimeter << *it;
	    }
	}
	
	int main()
	{
	    int n = ReadInt();
	    vector<int> arr = ReadVector<int>(ARR_LEN);
	    Solution solu;
	    vector<int> res = solu.GetBestTimeWindow(n, arr);
	    WriteVector(res);
	    return 0;
	}
