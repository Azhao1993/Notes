
##1.线程是什么？进程是什么？二者有什么区别和联系？
	（1）线程是CPU独立运行和独立调度的基本单位；
	（2）进程是资源分配的基本单位；是正在执行的应用程序
	
	联系：
		进程和线程都是操作系统所运行的程序运行的基本单元。
	
	区别：
		（1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。
		（2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。
	
	进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

 

##2、线程和进程各自有什么区别和优劣呢？ 

	进程是资源分配的最小单位，线程是程序执行的最小单位。
	
	进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，
	建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
	而线程是共享进程中的数据的，使用相同的地址空间，
	因此CPU切换一个线程的花费远比进程要小很多，
	同时创建一个线程的开销也比进程要小很多。
	
	线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，
	而进程之间的通信需要以通信的方式（IPC)进行。
	不过如何处理好同步与互斥是编写多线程程序的难点。
	
	但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，
	而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

 
##3、创建线程有几种不同的方式？你喜欢哪一种？为什么？

	A.继承Thread类
	B.实现Runnable接口
	C.应用程序可以使用Executor框架来创建线程池 
	
	实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。
	在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。
	同时，线程池也是非常高效的，很容易实现和使用。 

##4、概括的解释下线程的几种可用状态。 
	
	线程在执行过程中，可以处于下面几种状态：
	就绪(Runnable):线程准备运行，不一定立马就能开始执行。
	运行中(Running)：进程正在执行线程的代码。
	等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。
	睡眠中(Sleeping)：线程被强制睡眠。
	I/O阻塞(Blocked on I/O)：等待I/O操作完成。
	同步阻塞(Blocked on Synchronization)：等待获取锁。
	死亡(Dead)：线程完成了执行。

 
##5、同步方法和同步代码块的区别是什么？
 

在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。


Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。

     （1）、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

     （2）、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

     （3）、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。

     （4）、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

     （5）、以上规则对其它对象锁同样适用。

 

6、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？
 

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

 

7、什么是死锁(deadlock)？
 

两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。

 

8、如何确保N个线程可以访问N个资源同时又不导致死锁？
 

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。
 

9、如何避免死锁?
多线程产生死锁的四个必要条件：
互斥条件：一个资源每次只能被一个进程使用。
保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。
不可剥夺调教：进程已获得资源，在未使用完成前，不能被剥夺。
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
只要破坏其中任意一个条件，就可以避免死锁，其中最简单的就是破环循环等待条件。按同一顺序访问对象，加载锁，释放锁。