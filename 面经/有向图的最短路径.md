**题目描述**

给定单板间的有向连接关系: 如单板101到单板102存在连接，权值为10，其连接关系描述为:`101 102 10`；

单板102到单板101存在连接，权值为6，其连接关系手述为`102 101 6`;

基于单板间的有向连接关系，从起始单板到目的单板可能有0或多条可达的有向路径，某条路径权值是该路径上各连

接的权值之和。

给定多组格式为 ` 起始单板 目的单板 ` 的查询命令，请依次计算并返回其最佳路径权值; 若某条最佳路径不存在，

则该条最佳路径权值返回`-1`。

**输入**

首行为两个正整数` n m `

n 是单板问连接关系的数量，取值范围: [1, 500]

m 是查询命令的个数，取值范围:[1, 500]

接下来n行，每行是连接关系，单板六号取值范围: [1,999]，权值取值范围; [1,100]; 都为正整数

接下来m行，每行是需要查询最佳路径权值的起始单板、目的单板的编号。

**输出**

m行，每行一个整数，表示对应起始单板、目的单板的最佳路径权值的查询结果

**样例**

输入样例1

	2 2
	100 101 10
	102 101 5
	100 101
	102 100

输出样例1

	10
	-1

**提示**



- 样例1解释：

    输出第一行; 单板100到单板101 ，最少经过1次跳转就可达，其权值为10，输出10

    输出第二行: 单槐102到单板100，没有路径可达，因此输出-1

	#include <iostream>
	#include <map>
	#include <queue>
	using namespace std;
	
	class Solution {
	public:
	    // 待实现函数，在此函数中填入答题代码;
	    vector<int> GetBestRoute(const vector<vector<int>> &connection, const vector<vector<int>> &routes) const
	    {
	        return vector<int>();
	    }
	};
	
	int main()
	{
	    int n, m;
	    cin >> n >> m;
	    int board1, board2, weight;
	    vector<vector<int>> connections(n, vector<int>(3, 0));
	    for (int loop = 0; loop < n; loop++) {
	        cin >> board1 >> board2 >> weight;
	        connections[loop][0] = board1;
	        connections[loop][1] = board2;
	        connections[loop][2] = weight;
	    }
	
	    vector<vector<int>> routes(m, vector<int>(2, 0));
	    for (int loop = 0; loop < m; loop++) {
	        cin >> board1 >> board2;
	        routes[loop][0] = board1;
	        routes[loop][1] = board2;
	    }
	
	    Solution solu;
	    vector<int> res = solu.GetBestRoute(connections, routes);
	    for (auto r : res) {
	        cout << r << endl;
	    }
	
	    return 0;
	}
	
	
